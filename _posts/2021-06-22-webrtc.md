---
layout: post
title: ä½é…å»¶é…ä¿¡ã‚’ç›®æŒ‡ã—ã¦WebRTCã«è¡Œãç€ã„ãŸè©±
tags:
- Live
- WebRTC
---

[å‰å›ã®è¨˜äº‹ã®é€šã‚Š](/cast-architecture) HLSã‚’ä½¿ã£ãŸå‹•ç”»é…ä¿¡ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã—ã€å®Ÿéš›ã«å…¬é–‹å®Ÿé¨“ã¨ã—ã¦æ•°å›ã®é…ä¿¡ã‚’è¡Œã„ã¾ã—ãŸã€‚

`nginx-rtmp` ã‚„ `OBS` ã®è¨­å®šã‚’çµ¶å¦™ã«èª¿æ•´ã—ã¦ã‚‚ã€è¦–è´è€…å´ã«ã¯5~10ç§’ç¨‹åº¦ã®é…å»¶ãŒç”Ÿã˜ã¦ã—ã¾ã„ã¾ã—ãŸã€‚ãã®é…å»¶ã‚’è§£æ¶ˆã™ã‚‹ãŸã‚ `WebRTC` ã¸ç§»è¡Œã—ã¦ã¿ãŸè¨˜äº‹ã«ãªã‚Šã¾ã™ã€‚


## mediasoup

[mediasoup](https://github.com/versatica/mediasoup) ã¯Node.jså‘ã‘ã«ã‚‚APIãŒæä¾›ã•ã‚Œã¦ã„ã‚‹WebRTCã®SFUã§ã™ã€‚
ã¡ã‚‡ã£ã¨ã‚¬ãƒæ„Ÿã‚’æ„Ÿã˜ã¤ã¤ã€APIãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã‚‚å……å®Ÿã—ã¦ã„ã¦ã€Node.jsã¨TypeScriptã§ä½¿ãˆã‚‹ã¨ã„ã†äº‹ã§å½“åˆæ¡ç”¨ã€‚

ã‚¹ãƒ¼ãƒ—ã«å¯¾ã™ã‚‹å®¹å™¨ã¨ã„ã†äº‹ã§ã€ŒVesselã€ã¨ã„ã†åå‰ã«ã—ã€è¤‡é›‘ãªAPIã®æ‰‹ç¶šãã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæŒ‡å‘ã«ç³–è¡£ã—ã¦éš è”½ã™ã‚‹æ‰‹æ³•ã§ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã€‚
ã‚µãƒ³ãƒ—ãƒ«ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’å‚è€ƒã«ã—ã¤ã¤ã€ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã§ãƒ­ãƒ¼ã‚«ãƒ«ã‚¨ãƒªã‚¢ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯å†…ã§å‹•ä½œã™ã‚‹æ‰€ã¾ã§é–‹ç™ºãŒé€²æ—ã€‚

**media/src/Vessel.ts**
```
import { Server as SocketServer, Socket } from 'socket.io';
import * as mediasoup from 'mediasoup';
import type { types as Mediasoup } from 'mediasoup';
import { mediaCodecs } from './codecs';
import EventDispatcher from '@misinoe/typed-event-dispatcher';


type KindAndRtpParameters = {kind: 'video' | 'audio', rtpParameters: Mediasoup.RtpParameters};

export class VesselRoom {
  socketServer: SocketServer;
  worker: Mediasoup.Worker | undefined;
  router: Mediasoup.Router | undefined;

  produceTransport: Mediasoup.WebRtcTransport;
  producer: Mediasoup.Producer;

  private clients: VesselClient[] = [];

  constructor(request: {}) {
    this.initialize();
  }

  private async initialize() {
    this.worker = await mediasoup.createWorker({
      rtcMinPort: 34780,
      rtcMaxPort: 34999,
      logLevel: 'debug',
    });

    const {worker} = this;
    this.router = await worker.createRouter({
      mediaCodecs,
    });

    const {
      path = '/media',
      port = 3000,
    } = {};

    const socketServer = this.socketServer = new SocketServer({
      path,
    });

    socketServer.on('connection', (socket) => {
      const client = new VesselClient({
        room: this,
        socket,
      });
      this.clients.push(client);

      client.events.disconnect.once((client) => {
        this.clientWillDisconnect(client);
      });
    });

    socketServer.listen(port);
  }

  private clientWillDisconnect(client: VesselClient) {
    const {clients} = this;

    const index = clients.indexOf(client);
    if (index < 0) throw `Can't find client`;
    clients.splice(index, 1);
  }
}

class VesselClient {
  private room: VesselRoom;
  private socket: Socket;
  // private produceTransport: Mediasoup.WebRtcTransport;
  private cosumeTransport: Mediasoup.WebRtcTransport;
  private consumer: Mediasoup.Consumer;

  events = {
    disconnect: new EventDispatcher<VesselClient>(),
  };

  constructor(request: {room: VesselRoom, socket: Socket}) {
    this.room = request.room;
    this.socket = request.socket;

    const {socket} = this;
    socket.on('disconnect', () => {
      this.socketDisconnectHandler();
    });

    this.onSocketRequest('routerCapabilities', async () => {
      const {router} = this.room;
      const routerCapabilities: Mediasoup.RtpCapabilities = router.rtpCapabilities;

      return routerCapabilities;
    });

    this.onSocketRequest('createConsumerTransport', async () => {
      this.cosumeTransport = await this.createWebRtcTransport();

      const {cosumeTransport} = this;
      return {
        id: cosumeTransport.id,
        iceCandidates: cosumeTransport.iceCandidates,
        iceParameters: cosumeTransport.iceParameters,
        dtlsParameters: cosumeTransport.dtlsParameters,
      };
    });

    this.onSocketRequest('createProducerTransport', async () => {
      const {room} = this;

      room.produceTransport = await this.createWebRtcTransport();

      const {produceTransport} = room;
      return {
        id: produceTransport.id,
        iceCandidates: produceTransport.iceCandidates,
        iceParameters: produceTransport.iceParameters,
        dtlsParameters: produceTransport.dtlsParameters,
      };
    });

    this.onSocketRequest('connectProducerTransport', async (request: {dtlsParameters: Mediasoup.DtlsParameters}) => {
      const {dtlsParameters} = request;
      await this.room.produceTransport.connect({
        dtlsParameters,
      });
    });

    this.onSocketRequest('connectConsumerTransport', async (request: {dtlsParameters: Mediasoup.DtlsParameters}) => {
      const {dtlsParameters} = request;
      await this.cosumeTransport.connect({
        dtlsParameters,
      });
    });

    this.onSocketRequest<KindAndRtpParameters>('produce', async (request: {id: string, kind: Mediasoup.MediaKind, rtpParameters: Mediasoup.RtpParameters}) => {
      const {produceTransport} = this.room;
      this.room.producer = await produceTransport.produce({
        rtpParameters: request.rtpParameters,
        kind: request.kind,
      });

      return this.room.producer.id;
    });

    this.onSocketRequest<Mediasoup.RtpCapabilities>('consume', async (rtpCapabilities: Mediasoup.RtpCapabilities) => {
      const {room: {producer}} = this;
      const {cosumeTransport} = this;
      this.consumer = await cosumeTransport.consume({
        producerId: producer.id,
        rtpCapabilities: rtpCapabilities,
        // paused: producer.kind === 'video',
      });

      const {consumer} = this;

      return {
        producerId: producer.id,
        id: consumer.id,
        kind: consumer.kind,
        rtpParameters: consumer.rtpParameters,
        type: consumer.type,
        producerPaused: consumer.producerPaused
      };
    });
  }

  private async onSocketRequest<T = any>(name: string, closure: (param: T) => Promise<unknown>) {
    const {socket} = this;
    socket.on(name, async (param: T) => {
      const response = await closure(param);
      socket.emit(`re:${name}`, response);
    });
  }

  private async createWebRtcTransport() {
    const {router} = this.room;

    const transport = await router.createWebRtcTransport({
      listenIps: [
        {ip: '127.0.0.1'},
        {ip: '0.0.0.0', announcedIp: '192.168.12.7'},
      ],
      initialAvailableOutgoingBitrate: 1000000,
      enableUdp: true,
      enableTcp: true,
      preferUdp: true,
      enableSctp: true,
    });

    await transport.setMaxIncomingBitrate(1500000);

    return transport;
  }

  socketDisconnectHandler() {
    this.events.disconnect.dispatch(this);
  }
}
```

**next/libs/VesselClient.ts**
```
import {io as SocketIO, Socket} from 'socket.io-client';
import { Device } from 'mediasoup-client';
import type { types as Mediasoup } from 'mediasoup-client';
import { Stream } from 'node:stream';

type ProduceResponse = {kind: Mediasoup.MediaKind, rtpParameters: Mediasoup.RtpParameters};
type ConsumeResponse = {producerId: string, id: string, kind: Mediasoup.MediaKind, rtpParameters: Mediasoup.RtpParameters}

export class VesselClient {
  private device: Device;
  private socket: Socket;
  private videoProducer: Mediasoup.Producer;
  private audioProducer: Mediasoup.Producer;
  private dataProducer: Mediasoup.DataProducer;

  private consumer: Mediasoup.Consumer;

  constructor() {
    this.device = new Device();
  }

  async connectToVesselServer(path: string) {
    this.socket = SocketIO({
      path,
      autoConnect: false,
    });

    const {socket} = this;

    await new Promise<void>((resolve) => {
      socket.on('connect', resolve);
      socket.connect();
    });
  }

  async requestSocket<T>(requestName: string, params?: any): Promise<T> {
    const {socket} = this;
    return await new Promise((resolve) => {
      socket.emit(requestName, params);
      socket.once(`re:${requestName}`, (response: T) => {
        resolve(response);
      });
    });
  }

  private routerRtpCapabilities: Mediasoup.RtpCapabilities | undefined;

  async requestRouterCapabilities() {
    this.routerRtpCapabilities = await this.requestSocket<Mediasoup.RtpCapabilities>('routerCapabilities');

    const {device, routerRtpCapabilities} = this;
    await device.load({routerRtpCapabilities});

    return routerRtpCapabilities;
  }

  async subscribe() {
    const {device} = this;
    const transportOptions = await this.requestSocket<Mediasoup.TransportOptions>('createConsumerTransport');
    const receiveTransport = device.createRecvTransport(transportOptions);

    receiveTransport.on('connect', async (response: {dtlsParameters: Mediasoup.DtlsParameters}, successCallback: () => void, errorCallback: () => void) => {
      this.requestSocket('connectConsumerTransport', {
        transportId: transportOptions.id,
        dtlsParameters: response.dtlsParameters,
      }).then(successCallback).catch(errorCallback);
    });

    receiveTransport.on('connectionstatechange', async (state) => {
      console.log({state});
    });

    const {rtpCapabilities} = this.device;
    const consumeResponse = await this.requestSocket<ConsumeResponse>('consume', rtpCapabilities);

    this.consumer = await receiveTransport.consume({
      producerId: consumeResponse.producerId,
      id: consumeResponse.id,
      kind: consumeResponse.kind,
      rtpParameters: consumeResponse.rtpParameters,
    });

    const {consumer} = this;

    const mediaStream = new MediaStream();
    mediaStream.addTrack(consumer.track);
    return mediaStream;
  }

  async publish(publishMedia: {video: boolean, audio: boolean}) {
    const {device} = this;

    const transportOptions = await this.requestSocket<Mediasoup.TransportOptions>('createProducerTransport');
    const sendTransport = device.createSendTransport(transportOptions);

    sendTransport.on('connect', async (response: {dtlsParameters: Mediasoup.DtlsParameters}, successCallback: () => void, errorCallback: () => void) => {
      console.log('connected');
      this.requestSocket('connectProducerTransport', {
        transportId: transportOptions.id,
        dtlsParameters: response.dtlsParameters,
      }).then(successCallback).catch(errorCallback);
    });
    sendTransport.on('produce', async (response: ProduceResponse, successCallback: ({id: string}) => void, errorCallback: () => void) => {
      const producerId = await this.requestSocket<string>('produce', {
        transportId: sendTransport.id,
        kind: response.kind,
        rtpParameters: response.rtpParameters,
      });
      console.log('produce', producerId);
      successCallback({id: producerId});
    });

    sendTransport.on('connectionstatechange', (status: string) => {
      console.log({status});
      switch (status) {
        case 'connecting':
          break;
        case 'connected':
          break;
      }
    });

    const {video, audio} = publishMedia;
    const stream = await navigator.mediaDevices.getUserMedia({
      video,
      // audio,
    });

    if (video) {
      const videoTrack = stream.getVideoTracks()[0];
      this.videoProducer = await sendTransport.produce({
        track: videoTrack,
        encodings: [
          { maxBitrate: 100000 },
          { maxBitrate: 300000 },
          { maxBitrate: 900000 },
        ],
      });
    }

    return stream;
  }
}

```

**next/pages/play/cast.tsx**
```
import { VesselClient } from 'libs/VesselClient';
import * as React from 'react';

interface Props {}

const Play: React.FC<Props> = () => {
  // const [vesselClient, setVesselClient] = React.useState<VesselClient | null>(null);
  const videoRef = React.useRef<HTMLVideoElement>();

  React.useEffect(() => {
    (async () => {
      const vesselClient = new VesselClient();
      await vesselClient.connectToVesselServer('/media');
      await vesselClient.requestRouterCapabilities();
      const stream = await vesselClient.publish({video: true, audio: true});
      if (videoRef.current) videoRef.current.srcObject = stream;
    })();
  }, []);

  return <>
    <video controls autoPlay ref={videoRef}></video>
  </>;
}

export default Play;
```

**next/pages/play/receive.tsx**
```
import { VesselClient } from 'libs/VesselClient';
import * as React from 'react';

interface Props {}

const Play: React.FC<Props> = () => {
  const videoRef = React.useRef<HTMLVideoElement>();

  React.useEffect(() => {
    (async () => {
      const vesselClient = new VesselClient();
      await vesselClient.connectToVesselServer('/media');
      await vesselClient.requestRouterCapabilities();
      const stream = await vesselClient.subscribe();

      console.log({stream});
      if (videoRef.current) videoRef.current.srcObject = stream;

    })();
  }, []);

  return <>
    <video controls autoPlay ref={videoRef}></video>
  </>;
}

export default Play;
```

è¦‹ã¦ã®é€šã‚Šã‚³ãƒ¼ãƒ‰é‡ãŒå¤šããªã‚Šã¾ã—ãŸã€‚
ã“ã“ã¾ã§ã‚„ã£ã¦ã‚‚ã€ã‚„ã¯ã‚ŠAPIãŒè¤‡é›‘ã§ä»•çµ„ã¿ã‚’ãƒ‘ãƒ¼ãƒ•ã‚§ã‚¯ãƒˆã«ç†è§£ã§ããªã„äº‹ã«ä¸å®‰ã‚’è¦šãˆã€ä»–ã®æ‰‹æ®µã®æ¨¡ç´¢ã‚’é–‹å§‹ã—ã¾ã—ãŸã€‚


## PeerJS

PeerJSã«å‡ºä¼šã„ã¾ã™ã€‚
ç°¡ä¾¿ãªAPIã§ã€æ˜”ã‹ã‚‰å¤šãä½¿ã‚ã‚Œã¦ã„ã‚‹æ¨¡æ§˜ã€‚
ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹ã‚‚è¡Œã‚ã‚Œã¦ã„ã‚‹äº‹ã‹ã‚‰è©¦é¨“çš„ã«ä½¿ç”¨ã‚’é–‹å§‹ã—ã¾ã—ãŸã€‚

ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã§ã€receiveå´ã®IDã‚’castå´ã«æ‰‹å‹•å…¥åŠ›ã‚’è¦ã—ã¤ã¤ã€å‹•ç”»/éŸ³å£°ã®é…ä¿¡ãŒã§ãã¾ã—ãŸã€‚

ç¾æ™‚ç‚¹ã§Next.jsã§peerjsã‚’importã™ã‚‹æ™‚ã€SSRæ™‚ã« `navigator is not defined` ã®ã‚¨ãƒ©ãƒ¼ãŒç”Ÿã˜ã‚‹ãŸã‚ã€requireéƒ¨åˆ†ã‚’å·¥å¤«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã—ãŸã€‚

**next/pages/live/cast.tsx**
```
import * as React from 'react';
import Layout from 'components/Layout';
import type PeerType from 'peerjs';

let Peer: typeof PeerType;
if (typeof navigator !== 'undefined') {
  Peer = require("peerjs").default;
}

const Cast: React.FC = (props) => {
  const [mediaStream, setMediaStream] = React.useState<MediaStream | null>(null);
  const [peer, setPeer] = React.useState<PeerType | null>(null);
  const [peerId, setPeerId] = React.useState<string | null>(null);

  const callIdInputRef = React.useRef<HTMLInputElement>();
  const [callId, setCallId] = React.useState<string | null>();

  React.useEffect(() => {
    (async () => {
      console.log('media');
      const mediaStream = await new Promise<MediaStream>((resolve, reject) => {
        navigator.getUserMedia({video: true, audio: true}, resolve, reject)
      });

      setMediaStream(mediaStream);
    })();
  }, []);


  React.useEffect(() => {
    const peer = new Peer({
      host: 'localhost',
      port: 8080,
      path: '/peer',
      config: {
        iceServers: [
          {urls: 'stun:stun.l.google.com:19302'},
          {urls: 'stun:stun1.l.google.com:19302'},
        ],
      },
    });
    setPeer(peer);

    peer.on('connection', (connection) => {
      console.log('connection', connection);
    });
    peer.on('open', (id) => {
      console.log('open', id);
      setPeerId(id);
    });

    return () => {
      peer.disconnect();
    }
  }, []);

  React.useEffect(() => {
    if (!peer || !mediaStream) return;

    peer.on('call', (call) => {
      call.answer(mediaStream);
    });
  }, [mediaStream, peer]);

  const call = (callId: string) => {
    peer.call(callId, mediaStream);
  };

  return <Layout title="Peer">
    <p>{peerId}</p>
    <input ref={callIdInputRef}></input>
    <button onClick={() => {call(callIdInputRef.current?.value || '')}}>Call</button>
  </Layout>
}
export default Cast;
```

**next/pages/live/receive.tsx**
```
import * as React from 'react';
import Layout from 'components/Layout';
import type PeerType from 'peerjs';

let Peer: typeof PeerType;
if (typeof navigator !== 'undefined') {
  Peer = require("peerjs").default;
}

const Receive: React.FC = (props) => {
  const videoRef = React.useRef<HTMLVideoElement>();
  const [peer, setPeer] = React.useState<PeerType>();
  const [peerId, setPeerId] = React.useState<string | null>(null);


  React.useEffect(() => {
    const peer = new Peer({
      host: 'localhost',
      port: 8080,
      path: '/peer',
      config: {
        iceServers: [
          {urls: 'stun:stun.l.google.com:19302'},
          {urls: 'stun:stun1.l.google.com:19302'},
        ],
      },
    });
    setPeer(peer);

    peer.on('connection', (id) => {
      console.log('connection', id);
    });
    peer.on('open', (id) => {
      console.log('connection', id);
      setPeerId(id);
    });

    peer.on('call', call => {
      call.answer();
      call.on('stream', stream => {
        console.log(stream);
        videoRef.current.srcObject = stream;
      });
    });

    return () => {
      peer.disconnect();
    }
  }, []);

  return <Layout title="receive">
    <p>{peerId}</p>
    <video ref={videoRef} controls autoPlay></video>
  </Layout>;
};

export default Receive;
```

ã¾ãŸSTUNã‚µãƒ¼ãƒãƒ¼ã‚’è‡ªå‰ã§å»ºã¦ã‚‹å ´åˆã¯æ¬¡ã®é€šã‚Šã§ã§ãã¾ã—ãŸã€‚ç°¡å˜ã€‚

**peer/src/index.ts**
```
import {PeerServer} from 'peer';

const peerServer = PeerServer({
  port: 3000,
  proxied: true,
  path: '/peer',
  allow_discovery: true,
});

peerServer.on('connection', (client) => {
  console.log('connection', client);
});
```

ã“ã“ã¾ã§ä½œã‚Šã¾ã—ãŸãŒã€TURNã‚µãƒ¼ãƒãƒ¼ã‚’ã©ã†ã—ã‚ˆã†ã¨ã„ã†å•é¡Œã«è¡çªã—ã¾ã™ã€‚


## SkyWay

ãã—ã¦ `NTT Communications` ãŒæä¾›ã™ã‚‹ `SkyWay` ã‚’çŸ¥ã‚Šã¾ã™ã€‚
STUN/TURN/SFUå…¨ã¦ãŒæä¾›ã•ã‚Œã¦ã„ã¦ã€æ–™é‡‘å½¢æ…‹ã¯ç„¡æ–™ç‰ˆã¨æœ‰æ–™ç‰ˆã®2ã¤å­˜åœ¨ã—ã¦ã„ã¾ã™ã€‚

![SkyWay Pricing](../images/2021-06-22/SkyWay_Pricing.png)

50ä¸‡å›/æœˆã€TURNã¨SFUãŒ500GB/æœˆã¨ã€å€‹äººã§åˆ©ç”¨ã™ã‚‹ã«ã¯ååˆ†ã€‚
ãŸã ã—ãã‚Œã‚’è¶…ãˆã‚‹å ´åˆã¯æœˆé¡11ä¸‡å††~ã¨ã€æ³•äººã‚’æƒ³å®šã—ãŸä¾¡æ ¼â€¦ãã£ã¨è¶…ãˆãªã„ã¨æ€ã„ã¤ã¤ã€‚


**next/libs/peer.ts**
```
import Peer from 'skyway-js';

export const createPeer = () => {
  const peer = new Peer({
    key: process.env['NEXT_PUBLIC_SKYWAY_API_KEY'],
  });

  return peer;
};

export {
  Peer,
}
```

**next/pages/cast/[liveId].tsx**
```
import * as React from 'react';
import {createPeer, Peer} from 'libs/peer';

const Cast: React.FC<Props> = (props) => {
  const previewVideoRef = React.useRef<HTMLVideoElement | null>(null);
  const [mediaStream, setMediaStream] = React.useState<MediaStream | null>(null);

  React.useEffect(() => {
    const peer = createPeer();

    peer.on('open', (id) => {
      const meshRoom = peer.joinRoom(props.liveId, {
        mode: 'mesh',
        stream: mediaStream,
      });
    });

    return () => {
      peer.disconnect();
    }
  }, [mediaStream]);

  React.useEffect(() => {
    if (!previewVideoRef.current) return;

    navigator.getUserMedia({
      video: {
        width: {max: 1280},
        height: {max: 720},
      },
      audio: true,
    }, (mediaStream) => {
      previewVideoRef.current.srcObject = mediaStream;
      setMediaStream(mediaStream);
    }, () => {});
  }, [previewVideoRef.current]);

  return <>
    <video muted autoPlay ref={previewVideoRef} width="100%"></video>
  </>;
};
```


**next/pages/play/[liveId].tsx**
```
import * as React from 'react';
import {createPeer, Peer} from 'libs/peer';
...

const Play: React.FC<Props> = (props) => {
  const videoRef = React.useRef<HTMLVideoElement | null>(null);
  const [mediaStream, setMediaStream] = React.useState<MediaStream | null>(null);

  React.useEffect(() => {
    const peer = createPeer();

    peer.on('open', (id) => {
      setPeer(peer);
      setPeerId(id);

      const meshRoom = peer.joinRoom(props.liveId, {
        mode: 'mesh',
      });

      meshRoom.on('stream', (stream) => {
        setMediaStream(stream);
      });
    });

    return () => {
      peer.disconnect();
    }
  }, []);

  React.useEffect(() => {
    if (!videoRef.current) return;
    if (!mediaStream) return;

    videoRef.current.srcObject = mediaStream;
  }, [videoRef.current, mediaStream]);

  ...

  return <>
    <video controls autoPlay muted={muted} ref={videoRef}></video>
  </>;
};

export default Play;
```

ãŠãŠã‚ˆãã€ä¸Šè¨˜ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã§é…ä¿¡/è¦–è´ã®ä»•çµ„ã¿ãŒå®Œæˆã—ã¾ã—ãŸã€‚


## ãƒ†ã‚¹ãƒˆé…ä¿¡ã¨çµæœ

SkyWayã‚’åˆ©ç”¨ã™ã‚‹ã‚³ãƒ¼ãƒ‰ã«ç½®ãæ›ãˆã¦ã€å†ã³é…ä¿¡ã®ãƒ†ã‚¹ãƒˆã‚’ãŠã“ã„ã¾ã—ãŸã€‚


<blockquote class="twitter-tweet"><p lang="ja" dir="ltr">ã¿è™ <a href="https://t.co/20mQqj4w6z">pic.twitter.com/20mQqj4w6z</a></p>&mdash; ã»ã®ğŸ–ã‹ã‚‰ã‚‹ğŸ† (@hono_ESW9) <a href="https://twitter.com/hono_ESW9/status/1404083616506793984?ref_src=twsrc%5Etfw">June 13, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>


ç´„3æ™‚é–“ã®é…ä¿¡ã§ãƒªã‚¹ãƒŠãƒ¼æ•°ã¯å¹³å‡ç´„10äººã€SkyWayã®APIåˆ©ç”¨ã‚«ã‚¦ãƒ³ãƒˆã¯æ¬¡ã®é€šã‚Šã€‚

![SkyWay API Count](../images/2021-06-22/SkyWay_API_Count.png)


ãƒªã‚¹ãƒŠãƒ¼ã®å ±å‘Šã«ã‚ˆã‚‹ã¨ã€å‹•ç”»ã®é…å»¶ã¯ãªã‚“ã¨1ç§’æœªæº€ã«æŠ‘ãˆã‚‰ã‚Œã¦ã„ãŸã¨ã®äº‹ã€‚


## ã¾ã¨ã‚

* HLSã®é…ä¿¡é…å»¶ã‚’è§£æ¶ˆã—ã‚ˆã†ã¨WebRTCã«ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã—ãŸ
* mediasoupã¯ã¨ã¦ã‚‚é›£ã—ãã€çµæœçš„ã«ã¯æŒ«æŠ˜ã—ãŸ
* PeerJSã¯APIãŒç°¡ä¾¿ã§ä½¿ã„ã‚„ã™ã„äº‹ãŒã‚ã‹ã£ãŸ
* ã—ã‹ã—TURNã‚µãƒ¼ãƒãƒ¼ã‚’ã©ã†ã™ã‚‹ã‹ã¨ã„ã†å•é¡ŒãŒæµ®ä¸Šã—ã¦ãã‚‹
* SkyWayã¯STUN/TURN/SFUã‚’æä¾›ã—ã¦ãã‚Œã¦ã€PeerJSã¨åŒã˜ãã‚‰ã„ç°¡ä¾¿ãªAPIã§ç„¡æ–™æ ã®å¹…ãŒåºƒã„ã€ç´ æ™´ã‚‰ã—ã„ã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ã ã¨æ€ã£ãŸ
* é…ä¿¡é…å»¶ã‚’1ç§’æœªæº€ã«æŠ‘ãˆã‚‹äº‹ã«æˆåŠŸã—ãŸ
